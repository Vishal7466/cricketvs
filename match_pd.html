<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced AI Cricket Predictor — Monte Carlo (Client)</title>
<style>
  body{font-family:Inter,system-ui,Arial;margin:18px;background:#f5f7fb;color:#0b1320}
  .card{background:white;border-radius:10px;padding:14px;margin-bottom:14px;box-shadow:0 6px 18px rgba(20,30,60,0.06)}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0b84ff;color:white;cursor:pointer}
  pre{background:#0f172433;padding:8px;border-radius:6px;overflow:auto}
  .muted{color:#667085;font-size:13px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
</style>
</head>
<body>

<h2>Advanced AI Cricket Predictor (International only)</h2>
<div class="card">
  <div class="muted">Paste your CricketData API key below (it stays in your browser only).</div>
  <div class="row" style="margin-top:8px">
    <input id="apiKey" placeholder="CricketData API Key" style="padding:8px;border-radius:8px;border:1px solid #dfe7f2;width:360px" />
    <button onclick="loadMatches()">Load Live International Matches</button>
    <select id="sims" style="padding:8px;border-radius:8px">
      <option value="500">500 sims</option>
      <option value="1000" selected>1000 sims</option>
      <option value="3000">3000 sims (slow)</option>
    </select>
  </div>
</div>

<div id="matchesCard" class="card" style="display:none">
  <h3>Live International Matches</h3>
  <div id="matchList" class="muted">—</div>
</div>

<div id="liveCard" class="card" style="display:none">
  <h3 id="matchTitle">Match</h3>
  <div class="muted" id="matchMeta"></div>

  <div style="margin-top:8px" id="scoreRow"></div>

  <div style="margin-top:12px">
    <button onclick="runPrediction()">Run Advanced Prediction</button>
    <span class="muted" style="margin-left:10px">Will run Monte Carlo simulations in your browser (no server).</span>
  </div>

  <div id="results" style="margin-top:12px;display:none">
    <h4>Results</h4>
    <div id="summary"></div>
    <h5>Distribution summary (projected total)</h5>
    <pre id="dist"></pre>
    <h5>Top scorers frequency</h5>
    <pre id="topsc"></pre>
    <h5>Dismissal modes (aggregated)</h5>
    <pre id="dism"></pre>
    <h5>Raw fetched JSON</h5>
    <pre id="raw"></pre>
  </div>
</div>

<script>


  const API_KEY = "d148671e-e9db-4319-af93-ff76a71b62da ";
/* ----------------- CONFIG ----------------- */
const API_BASE_CURRENT = (key) => `https://api.cricapi.com/v1/currentMatches?apikey=${key}&offset=0`;
const API_BASE_MATCH = (key, id) => `https://api.cricapi.com/v1/match_info?apikey=${key}&id=${encodeURIComponent(id)}`;
const INTERNATIONAL_TAGS = ['international','International','TEST','ODI','T20I'];

/* ----------------- UI helpers ----------------- */
const el = id => document.getElementById(id);

/* ----------------- Load matches ----------------- */
async function loadMatches(){
  const key = el('apiKey').value.trim();
  if(!key){ alert('Paste your CricketData API key'); return; }
  el('matchList').textContent = 'Loading…';
  try{
    const res = await fetch(API_BASE_CURRENT(key));
    const jd = await res.json();
    if(!jd || !jd.data){ el('matchList').textContent = 'No response or no matches'; return; }
    // filter internationals
    const ints = jd.data.filter(m => {
      const mt = (m.matchType||m.type||'').toString().toLowerCase();
      return INTERNATIONAL_TAGS.some(t => mt.includes(t.toString().toLowerCase()));
    });
    if(ints.length===0){ el('matchList').textContent = 'No international live matches'; return; }
    let html='';
    ints.forEach(m=>{
      const t1 = (m.teams && m.teams[0]) || (m.teamA) || (m.name||'TeamA');
      const t2 = (m.teams && m.teams[1]) || (m.teamB) || (m.series || 'TeamB');
      const mid = m.id || m.match_id || m.unique_id || m.matchId || '';
      const status = m.status || m.statusText || m.matchStarted ? 'Live': (m.title || '');
      html += `<div style="padding:8px;border-bottom:1px solid #eef;margin-bottom:8px">
        <b>${t1} vs ${t2}</b><br>
        <span class="muted">Match ID: ${mid} — ${status}</span><br>
        <button onclick="selectMatch('${mid}')">Select this match</button>
      </div>`;
    });
    el('matchList').innerHTML = html;
    el('matchesCard').style.display = 'block';
  }catch(e){
    el('matchList').textContent = 'Error fetching matches: ' + e.message;
    console.error(e);
  }
}

/* ----------------- Select match & fetch live details ----------------- */
let CURRENT_MATCH = null;
async function selectMatch(matchId){
  const key = el('apiKey').value.trim();
  if(!key){ alert('Paste your CricketData API key'); return; }
  if(!matchId){ alert('No match ID'); return; }
  el('matchTitle').textContent = 'Loading match ' + matchId + '…';
  el('matchMeta').textContent = '';
  try{
    const res = await fetch(API_BASE_MATCH(key, matchId));
    const jd = await res.json();
    if(!jd){ alert('No JSON returned'); return; }
    CURRENT_MATCH = jd;
    el('raw').textContent = JSON.stringify(jd, null, 2);
    const live = extractLive(jd);
    // show summary
    el('matchTitle').textContent = (jd.name || jd.data && jd.data.name) || `Match ${matchId}`;
    el('matchMeta').textContent = (live.venue ? live.venue + ' | ' : '') + (live.status || '');
    el('scoreRow').innerHTML = `
      <div class="row" style="gap:12px">
        <div><b>Score:</b> ${live.scoreDisplay || (live.runs? live.runs+'/'+(live.wickets||'0'): '—')}</div>
        <div><b>Overs:</b> ${live.overs || '—'}</div>
        <div><b>RR:</b> ${live.runRate? Number(live.runRate).toFixed(2): '—'}</div>
        <div><b>Target:</b> ${live.target||live.required || '—'}</div>
      </div>`;
    el('liveCard').style.display = 'block';
    el('results').style.display = 'none';
  }catch(e){
    alert('Error: ' + e.message);
    console.error(e);
  }
}

/* ----------------- Best-effort extractor ----------------- */
function extractLive(json){
  // Many CricketData responses nest differently. Try common fields.
  const out = {};
  const data = (json.data && (Array.isArray(json.data)?json.data[0]:json.data)) || json;
  // Score pieces
  out.runs = (data.score && data.score.runs) || (data.score && data.score.full && data.score.full.runs) || data.runs || null;
  out.wickets = (data.score && (data.score.wkts || data.score.wickets)) || data.wickets || null;
  out.overs = (data.score && (data.score.overs || data.score.overs_played)) || data.overs || null;
  out.runRate = (data.score && (data.score.run_rate || data.score.rpo)) || (out.runs && out.overs ? (Number(out.runs) / parseFloat(out.overs || 1)) : null);
  out.scoreDisplay = (data.score && data.score.display) || (out.runs !== null ? `${out.runs}/${out.wickets || 0}` : null);
  out.target = data.target || data.match && data.match.target || data.required || null;
  out.status = data.status || data.statusText || data.matchStarted ? 'Live' : '';
  out.venue = data.venue || data.place || '';
  // batsmen / bowler
  out.batsmen = data.batting && data.batting.batsmen ? data.batting.batsmen : (data.batsmen || data.currentBatsmen || []);
  out.bowler = data.bowling && data.bowling.currentBowler ? data.bowling.currentBowler : (data.bowler || data.currentBowler || []);
  // recent last6 runs (if provided)
  out.recent = data.last6 || data.last_6 || data.recent; // number or array
  // teams
  out.teams = data.teams || data.team || (json.data && json.data.teams) || [];
  return out;
}

/* ----------------- Parameter estimation ----------------- */
function estimatePlayerParams(live){
  // for each batsman/bowler create {sr, avg, wicketRate, econ}
  // prefer API fields if present, else use role priors.
  const bats = (live.batsmen || []).map((b, idx) => {
    const name = b.name || b.player || `Batsman ${idx+1}`;
    const sr = b.strikeRate || b.sr || (b.runs && b.balls ? (b.runs / b.balls * 100) : null);
    const avg = b.avg || b.average || null;
    return {
      name, sr: sr? Number(sr) : (Math.random()*20 + 70), avg: avg? Number(avg) : (Math.random()*20 + 25)
    };
  });
  // if no batsmen provided, create placeholders for 11
  if(bats.length === 0){
    for(let i=1;i<=11;i++) bats.push({name:`Batsman ${i}`, sr: (Math.random()*20+75), avg:(Math.random()*25+20)});
  }
  // bowler(s)
  const bowl = (Array.isArray(live.bowler) ? live.bowler : (live.bowler? [live.bowler] : [])).map((b,idx)=>{
    const name = b.name || b.player || `Bowler ${idx+1}`;
    const econ = b.economy || b.econ || (b.overs && b.runs ? (b.runs / b.overs) : null);
    const wicketRate = b.wicketRate || (b.wickets && b.overs ? (b.wickets / (b.overs*6)) : null); // wickets per ball
    return {name, econ: econ? Number(econ) : (Math.random()*2 + 6), wicketRate: wicketRate? Number(wicketRate) : (Math.random()*0.02 + 0.02)};
  });
  // if none, create several generic bowlers
  if(bowl.length===0){
    for(let i=1;i<=5;i++) bowl.push({name:`Bowler ${i}`, econ:(Math.random()*2+6), wicketRate:(Math.random()*0.02+0.02)});
  }
  return {bats, bowl};
}

/* ----------------- Per-ball outcome probabilities (simple param model) ----------------- 
   We compute probability for events: 0,1,2,3,4,6,W
   Use batsman SR and bowler econ/wicketRate to bias probabilities.
*/
function perBallProb(batsman, bowler){
  // batsman.sr -> runs per 100 balls -> convert to runs per ball expectation
  const expRunsPerBall = (batsman.sr || 80) / 100;
  // bowler wicketRate (wickets per ball)
  const wkProb = Math.min(0.35, bowler.wicketRate || 0.03); // cap
  // adjust for bowler econ: lower econ => fewer boundaries
  const econFactor = Math.max(0.5, Math.min(1.6, 7 / (bowler.econ || 7))); // higher econ -> more runs
  const base = expRunsPerBall * econFactor;
  // distribute probabilities heuristically
  // higher base -> more chance for boundaries
  const p6 = Math.min(0.15, base*0.25);
  const p4 = Math.min(0.30, base*0.5);
  const p3 = Math.min(0.06, base*0.06);
  const p2 = Math.min(0.12, base*0.12);
  const p1 = Math.min(0.40, Math.max(0.12, 0.6 - base*0.2));
  const p0 = Math.max(0.05, 1 - (p1+p2+p3+p4+p6) - wkProb);
  // normalize (just in case)
  const arr = [{r:0,p:p0},{r:1,p:p1},{r:2,p:p2},{r:3,p:p3},{r:4,p:p4},{r:6,p:p6},{r:'W',p:wkProb}];
  const total = arr.reduce((s,x)=>s+x.p,0);
  return arr.map(a=>({r:a.r,p:a.p/total}));
}

/* ----------------- Simulation engine ----------------- */
function simulateOnce(state, params){
  // state: {runs, wickets, overs, ballsInOver, batsmen array with index, nextBatsmanIndex, target(if chasing), inningsOversLimit}
  // params: estimated players {bats, bowl}
  // simulate until innings complete (overs limit or all out or target chased if chasing)
  const outcome = {total: state.runs, topScorer: null, dismissalModes: {}};
  // clone local
  let runs = state.runs;
  let wickets = state.wickets;
  let balls = Math.round((state.overs || 0) *6 + (state.ballsInOver || 0));
  const maxBalls = (state.inningsOversLimit || 50)*6;
  const bats = JSON.parse(JSON.stringify(params.bats)); // each has name,sr,avg,score?
  bats.forEach(b=>b.runs= (b.runs||0));
  let onStrike = 0, nonStrike = 1;
  if(state.onStrikeIndex !== undefined) onStrike = state.onStrikeIndex;
  if(state.nonStrikeIndex !== undefined) nonStrike = state.nonStrikeIndex;
  let nextBatIdx = state.nextBatsmanIndex || 2;
  // get bowler rotation: simple cycle through params.bowl
  const bowlArr = params.bowl;
  while(balls < maxBalls && wickets < 10){
    const over = Math.floor(balls/6);
    const ballInOver = balls % 6;
    // choose current bowler (simple: rotate)
    const bowler = bowlArr[over % bowlArr.length];
    const batsman = bats[onStrike] || bats[0];
    // generate per-ball probs
    const p = perBallProb(batsman, bowler);
    // sample outcome
    const rnd = Math.random();
    let cum=0, chosen=null;
    for(const x of p){ cum+=x.p; if(rnd<=cum){ chosen=x.r; break; } }
    if(chosen === 'W'){
      wickets += 1;
      batsman.runs = batsman.runs || 0;
      // dismissal mode heuristic
      const mode = Math.random() < 0.6 ? 'caught' : (Math.random() < 0.5 ? 'bowled' : 'lbw');
      outcome.dismissalModes[mode] = (outcome.dismissalModes[mode]||0)+1;
      // new batsman comes in
      if(nextBatIdx < 11){
        onStrike = nextBatIdx;
        nextBatIdx++;
      } else {
        // all out
        break;
      }
    } else {
      // runs scored
      const r = Number(chosen);
      runs += r;
      batsman.runs = (batsman.runs || 0) + r;
      // rotate strike for odd runs
      if(r%2===1) { const t=onStrike; onStrike=nonStrike; nonStrike=t; }
    }
    balls++;
    // end of over -> swap strike
    if(balls%6===0){ const t=onStrike; onStrike=nonStrike; nonStrike=t; }
    // chasing check
    if(state.target && runs >= state.target){ break; }
  } // end while
  outcome.total = runs;
  // top scorer
  let top = bats.reduce((a,b)=> (b.runs > (a.runs||0) ? b : a), bats[0]);
  outcome.topScorer = {name: top.name, runs: top.runs||0};
  return outcome;
}

/* run many sims */
async function runPrediction(){
  if(!CURRENT_MATCH){ alert('Select a match first'); return; }
  el('results').style.display = 'none';
  const sims = Number(el('sims').value || 1000);
  el('summary').textContent = 'Running ' + sims + ' simulations — please wait...';
  // prepare state
  const live = extractLive(CURRENT_MATCH);
  const params = estimatePlayerParams(live);
  // initial state
  const ballsSoFar = parseOversToBalls(live.overs);
  const initialState = {
    runs: Number(live.runs) || 0,
    wickets: Number(live.wickets) || 0,
    overs: Number(live.overs) || 0,
    ballsInOver: (live.overs && live.overs.toString().includes('.') ? Number(live.overs.toString().split('.')[1]) : 0),
    target: live.target ? Number(live.target) : null,
    inningsOversLimit: 50,
    nextBatsmanIndex: (params.bats.length>2?2:params.bats.length),
    onStrikeIndex: 0,
    nonStrikeIndex: 1
  };

  // run sims
  const totals = [];
  const topFreq = {}; // name -> count
  const dismissalAgg = {};
  const batch = 50;
  for(let i=0;i<sims;i++){
    // simulate
    const o = simulateOnce(initialState, params);
    totals.push(o.total);
    if(o.topScorer && o.topScorer.name){
      topFreq[o.topScorer.name] = (topFreq[o.topScorer.name]||0)+1;
    }
    for(const [k,v] of Object.entries(o.dismissalModes||{})){
      dismissalAgg[k] = (dismissalAgg[k]||0)+v;
    }
    // small yield to UI for large sims
    if(i%batch===0){
      await new Promise(r=>setTimeout(r,0));
      el('summary').textContent = `Running ${sims} simulations — ${i}/${sims} done...`;
    }
  }

  // analyze distribution
  totals.sort((a,b)=>a-b);
  const median = totals[Math.floor(totals.length*0.5)];
  const p10 = totals[Math.floor(totals.length*0.1)];
  const p90 = totals[Math.floor(totals.length*0.9)];
  // win probability if chasing OR defending (if target present)
  let winProb = null;
  if(initialState.target){
    // count sims where total >= target
    const wins = totals.filter(t=>t >= initialState.target).length;
    winProb = wins / totals.length;
  } else {
    // if batting first (no target), we can compare against a par (e.g., 250)
    const par = 250;
    const wins = totals.filter(t=>t >= par).length;
    winProb = wins / totals.length;
  }

  // top scorers sorted
  const topSorted = Object.entries(topFreq).sort((a,b)=>b[1]-a[1]).slice(0,8);

  // prepare outputs
  el('summary').innerHTML = `
    <b>Projected median total:</b> ${median} <br>
    <b>10%–90% range:</b> ${p10} — ${p90} <br>
    <b>Win probability (by sims):</b> ${(winProb*100).toFixed(1)}% <br>
    <b>Simulations run:</b> ${sims}
  `;
  el('dist').textContent = `median: ${median}\n10%: ${p10}\n90%: ${p90}\n\nSample of totals (first 80):\n${totals.slice(0,80).join(', ')}`;
  el('topsc').textContent = topSorted.map(t=>`${t[0]} : ${(t[1]/sims*100).toFixed(1)}%`).join('\n');
  el('dism').textContent = Object.entries(dismissalAgg).map(x=>`${x[0]} : ${x[1]}`).join('\n');
  el('results').style.display = 'block';
}

/* utilities */
function parseOversToBalls(overs){
  if(!overs) return 0;
  const s = overs.toString();
  if(s.indexOf('.')>-1){
    const parts = s.split('.');
    const o = Number(parts[0]||0);
    const b = Number(parts[1]||0);
    return o*6 + b;
  }
  return Number(overs)*6;
}
</script>

</body>
</html>
